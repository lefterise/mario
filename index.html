<!DOCTYPE html>‚Äù
<html>
<head>
<meta name="apple-mobile-web-app-capable" content="yes">
<script src="graphics.js"></script>
<script src="levels.js"></script>
<script src="keyboard.js"></script>
<script src="touch.js"></script>
<script src="sound.js"></script>
<style>
html,
body {
  width: 100%;
  height: 100%;
  margin: 0;
}
canvas {
  display: block;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
}
</style>

<script>
class Animation{
  constructor(frames, transitionTime){
     this.frames = frames; 
     this.transitionTime = transitionTime;
	 this.frame = 0;
	 this.t = 0;
  }
  
  update(dt){
	 this.t = this.t + dt;
     let framesToAdvance = Math.floor(this.t / this.transitionTime);
	 this.frame = (this.frame + framesToAdvance) % this.frames;	
	 this.t = this.t - framesToAdvance * this.transitionTime;
  }
  
}

function noNaN(x){
	if (isNaN(x))
		return 0;
	return x;
}

class Terrain{
	constructor(tiles, world){
		this.tiles = tiles;
		this.tileWidth = 60;
		this.tileHeight = 42;
		this.bumpedBricks = [];
		this.world = world;
	}

	inBounds(X,Y){
		return X >= 0 && X < this.tiles.length && Y >= 0 && Y < this.tiles[X].length;
	}

	isSolid(X,Y){
		return this.inBounds(X,Y) && (this.tiles[X][Y] < 8 || [9,20,21,26,27,32,33,67].includes(this.tiles[X][Y]));
	}

	isBumpable(X, Y){
		return this.inBounds(X,Y) && [9, 10,11, 20].includes(this.tiles[X][Y]);
	}
	
	getPointCollisonDistance(x, y, dx, dy, tMax, wantNonSolid){		
        //Ref: A fast voxel traversal algorithm J.Amanatides, A. Woo      
		//(x,y) the location of the point. 
		//(dx, dy) the normalized speed of the point in pixels per second. 
		//tMax the number of seconds the point intents to travel

        //Distance in seconds between two consecutive lines when moving at direction (dx,dy)
        let tVertical    = this.tileWidth  / Math.abs(dx);
        let tHorizontal  = this.tileHeight / Math.abs(dy);

        //Starting Tile location
        let X = Math.floor(x / this.tileWidth);
        let Y = Math.floor(y / this.tileHeight);

		//Ending Tile location
        let endX = Math.floor((x + dx * tMax) / this.tileWidth);
        let endY = Math.floor((y + dy * tMax) / this.tileHeight);

		let tNextVertical, tNextHorizontal; //The distance in seconds to the next line
        let stepX, stepY;                   //The direction we move across tiles        

        if (dx >= 0.0){
            stepX = 1;
            tNextVertical = ((X+1) * this.tileWidth - x) / dx;
        }else{
            stepX = -1;
            tNextVertical = (X * this.tileWidth - x) / dx;
        }

        if (dy >= 0.0){
            stepY = 1;
            tNextHorizontal = ((Y+1) * this.tileHeight - y) / dy;
        }else{
            stepY = -1;
            tNextHorizontal = (Y * this.tileHeight - y) / dy;
        }

		if (isNaN(tNextVertical) || isNaN(tNextHorizontal)){
			debugger;
		}

        if (this.isSolid(X, Y) && !wantNonSolid) {
			//this tries to solve the problem if mario happens to be inside a solid block.
			//the idea is to flip the direction and call the inverse of this function to find the first non-solid
            return this.getPointCollisonDistance(x,y,-dx,-dy, 10000, true); 
        }

        let t = 0.0;
        while ((X != endX || Y !=endY) && (t < tMax)){
            if(tNextVertical < tNextHorizontal){
                t = tNextVertical;
                tNextVertical += tVertical;

				if (isNaN(tNextVertical)){
					debugger; //ading positive and negative infinity
				}

                X += stepX;

				if (this.isSolid(X, Y) ^ wantNonSolid) {
					if (!wantNonSolid){
                		return t - noNaN(stepX / dx); //Return t at one pixel before the collision with the solid vertical line
					} else {
						return t + noNaN(stepX / dx); //Return t at one pixel after the collision with the non-solid vertical line
					}
				}
            }else{
                t = tNextHorizontal;
                tNextHorizontal += tHorizontal;

				if (isNaN(tNextHorizontal)){
					debugger; //ading positive and negative infinity
				}

                Y += stepY;

				if (this.isSolid(X, Y) ^ wantNonSolid) {
					if (!wantNonSolid){
                		return t - noNaN(stepY / dy); //Return t at one pixel before the collision with the vertical line
					} else {
						return t + noNaN(stepY / dy);
					}
				}
            }
        }
        return tMax;
    }

	getMultipointCollisionDistance(x, y, dx, dy, tMax, collisionPoints){
		let minT = tMax;
		for (let p of collisionPoints){
			let t = this.getPointCollisonDistance(x + p.x, y + p.y, dx, dy, tMax, false);
			minT = Math.min(minT, t);
		}
		return minT;
	}

	bumpBrick(bumpedBricks, moveable){
		this.bumpedBricks = bumpedBricks;
		for (let b of bumpedBricks){
			if (this.tiles[b.x][b.y] == 20){
				if (this.tiles[b.x][b.y - 1] == 115){

					if (this.world.mario.size == 0){
						let mushroom = new Mushroom(60 * (b.x),42 * (b.y - 1), 0.1, 0.0);
						this.world.enemies.push(mushroom);
					}else{
						let flower = new Flower(60 * (b.x),42 * (b.y - 1), 0.0, 0.0);
						this.world.enemies.push(flower);
					}
					this.tiles[b.x][b.y] = 21;
					this.tiles[b.x][b.y - 1] = 255;

					sound.sprout.play();
				}else{
					this.tiles[b.x][b.y] = 21;
					sound.coin.play();
				}
			}else if (this.tiles[b.x][b.y] == 9){				
				if (moveable.size == 0){
					sound.bump.play(); //small mario
				}else{
					sound.break.play(); //large mario or koopa
					this.tiles[b.x][b.y] = 255;
					this.world.enemies.push(new BrickParticle(60 * b.x,42 * b.y ,  0.2, -0.5));
					this.world.enemies.push(new BrickParticle(60 * b.x,42 * b.y , -0.2, -0.5));
					this.world.enemies.push(new BrickParticle(60 * b.x,42 * b.y , 0.15, -0.75));
					this.world.enemies.push(new BrickParticle(60 * b.x,42 * b.y , -0.15, -0.75));
					this.world.enemies.push(new BrickParticle(60 * b.x,42 * b.y , 0.1, -0.8));
					this.world.enemies.push(new BrickParticle(60 * b.x,42 * b.y , -0.1, -0.8));
				}
			}
		}
	}
}

const States = {
	Idle: 0,
	Walking: 1,
	Cowering: 2,
	Spinning: 3,
	Dying: 4,
	Dead: 5,
	Collectable: 6,
	Solid: 7,
	Sprouting: 8
}

const CollisionPoints = {
	BottomLeft: 0,
	BottomRight: 1,
	TopLeft: 2,
	TopRight: 3
};

class Moveable{
	constructor(x, y, dx, dy){
		this.x = x;     //in pixels
		this.y = y;     //in pixels
		this.dx = dx;   //in pixels per millisecond
		this.dy = dy;   //in pixels per millisecond
		this.ay = 0.0025;  //in pixels per millisecond per millisecond
		this.dyTerminal = 1.0; //in pixels per millisecond
		this.isTouchingGround = false;
		this.isBumpingCeiling = false;
		this.collisionPoints = []; //The first four must be the corners: bottom-left, bottom-right, top-left, top-right (see CollisionPoints enum)
		this.futureX = x; //in pixels
		this.futureY = y; //in pixels		
		this.behaviours = [];
	}


	getRelativeLocationTo(other){
		let al = this.x + this.collisionPoints[CollisionPoints.BottomLeft].x;
		let ar = this.x + this.collisionPoints[CollisionPoints.TopRight].x;
		let at = this.y + this.collisionPoints[CollisionPoints.TopRight].y;
		let ab = this.y + this.collisionPoints[CollisionPoints.BottomLeft].y;

		let bl = other.x + other.collisionPoints[CollisionPoints.BottomLeft].x;
		let br = other.x + other.collisionPoints[CollisionPoints.TopRight].x;
		let bt = other.y + other.collisionPoints[CollisionPoints.TopRight].y;
		let bb = other.y + other.collisionPoints[CollisionPoints.BottomLeft].y;

		return {above: ab < bt, below: at > bb, left: ar < bl, right: al > br };
	}


	getDistanceFromOtherMoveable(other){
		let al = this.futureX + this.collisionPoints[CollisionPoints.BottomLeft].x;
		let ar = this.futureX + this.collisionPoints[CollisionPoints.TopRight].x;
		let at = this.futureY + this.collisionPoints[CollisionPoints.TopRight].y;
		let ab = this.futureY + this.collisionPoints[CollisionPoints.BottomLeft].y;

		let bl = other.futureX + other.collisionPoints[CollisionPoints.BottomLeft].x;
		let br = other.futureX + other.collisionPoints[CollisionPoints.TopRight].x;
		let bt = other.futureY + other.collisionPoints[CollisionPoints.TopRight].y;
		let bb = other.futureY + other.collisionPoints[CollisionPoints.BottomLeft].y;

		let dx1 = al - br;
		let dx2 = bl - ar;
		let dy1 = at - bb;
		let dy2 = bt - ab;

		return {dx: Math.max(dx1,dx2), dy: Math.max(dy1,dy2)};
	}

	calculateFuturePosition(dt, terrain){
		for (let b of this.behaviours){
			b.computeFuturePosition(this, dt, terrain);
		}
	}
	
	applyPosition(dt, terrain){
		this.x = this.futureX;
		this.y = this.futureY;

		for (let b of this.behaviours){
			b.reactToNewPosition(this, dt, terrain);
		}
	}
}

//Composable behaviors
class RespectsTerrain {
	computeFuturePosition(moveable, dt, terrain){
		if (isNaN(moveable.x) || isNaN(moveable.y)){
			debugger;
		}

		let tDiagonal = terrain.getMultipointCollisionDistance(moveable.x, moveable.y, moveable.dx, moveable.dy, dt, moveable.collisionPoints);
		
		if (isNaN(tDiagonal)){
			debugger;
			let runAgain = terrain.getMultipointCollisionDistance(moveable.x, moveable.y, moveable.dx, moveable.dy, dt, moveable.collisionPoints);
		}	

		let x = moveable.x + moveable.dx * tDiagonal;
		let y = moveable.y + moveable.dy * tDiagonal;
				
		//check if mario can move stricly in dx or dy for the remainder of the distance
		let tHorizontal = terrain.getMultipointCollisionDistance(x, y, moveable.dx, 0.0, dt - tDiagonal, moveable.collisionPoints);
		
		if (isNaN(tHorizontal)){
			debugger;
			let runAgain = terrain.getMultipointCollisionDistance(x, y, moveable.dx, 0.0, dt - tDiagonal, moveable.collisionPoints);
		}	

		x = x + moveable.dx * tHorizontal;	

		let tVertical = terrain.getMultipointCollisionDistance(x, y, 0.0, moveable.dy, dt - tDiagonal, moveable.collisionPoints);
		
		if (isNaN(tVertical)){
			debugger;
			let runAgain = terrain.getMultipointCollisionDistance(x, y, 0.0, moveable.dy, dt - tDiagonal, moveable.collisionPoints);
		}		

		y = y + moveable.dy * tVertical;
		

		if (isNaN(x) || isNaN(y)){
			debugger;
		}

		moveable.futureX = x;
		moveable.futureY = y;
	}


	reactToNewPosition(moveable, dt, terrain){
		moveable.isTouchingGround = terrain.getMultipointCollisionDistance(moveable.x, moveable.y, 0.0,  1.0, 2.0, moveable.collisionPoints) <= 1.0 || moveable.isStandingOnSolid;
		moveable.isBumpingCeiling = terrain.getMultipointCollisionDistance(moveable.x, moveable.y, 0.0, -1.0, 2.0, moveable.collisionPoints) <= 1.0 || moveable.isBumpingSolid;
		
		moveable.isStandingOnSolid = false;
		moveable.isBumpingSolid = false;

		if (!moveable.isTouchingGround)
			moveable.dy = Math.min(moveable.dy + moveable.ay * dt, moveable.dyTerminal);
		else if (moveable.dy > 0.0)
			moveable.dy = 0.0;

		if (moveable.isBumpingCeiling && moveable.dy < 0.0){
			moveable.dy = 0.0;			
		}
	}
}

class IgnoresTerrain{
	computeFuturePosition(moveable, dt, terrain){
		moveable.futureX = moveable.x + moveable.dx * dt;
		moveable.futureY = moveable.y + moveable.dy * dt;
	}

	reactToNewPosition(moveable, dt, terrain){		
		moveable.dy = Math.min(moveable.dy + moveable.ay * dt, moveable.dyTerminal);		
	}
}

class ChangesDirectionWhenHittingWalls{
	computeFuturePosition(moveable, dt, terrain){}
	
	reactToNewPosition(moveable, dt, terrain){
		let isHittingLeftWall  = terrain.getMultipointCollisionDistance(moveable.x, moveable.y, -1.0, 0.0, 2.0, moveable.collisionPoints) <= 1.0;
		let isHittingRightWall = terrain.getMultipointCollisionDistance(moveable.x, moveable.y,  1.0, 0.0, 2.0, moveable.collisionPoints) <= 1.0;

		if (isHittingLeftWall && !isHittingRightWall){
			moveable.dx = Math.abs(moveable.dx);
		}
		if (!isHittingLeftWall && isHittingRightWall){
			moveable.dx = -Math.abs(moveable.dx);
		}
	}
}

class CanBumpBricksAbove{
	computeFuturePosition(moveable, dt, terrain){}
	
	reactToNewPosition(moveable, dt, terrain){
		let bumpedBricks = this.getBumpedBricks(moveable, terrain);
		if (bumpedBricks.length > 0)
			terrain.bumpBrick(bumpedBricks, moveable);
	}

	getBumpedBricks(moveable, terrain){
		let x1 = Math.floor((moveable.x + moveable.collisionPoints[CollisionPoints.TopLeft].x) / terrain.tileWidth);
		let x2 = Math.floor((moveable.x + moveable.collisionPoints[CollisionPoints.TopRight].x) / terrain.tileWidth);
	    let y  = Math.floor((moveable.y + moveable.collisionPoints[CollisionPoints.TopRight].y - 2.0) / terrain.tileHeight);

		let bumpedBricks = [];
		if (terrain.isBumpable(x1, y)){
			bumpedBricks.push({x:x1, y:y});
		}
		
		if (x1 != x2 && terrain.isBumpable(x2, y)){
			bumpedBricks.push({x:x2, y:y});
		}

		return bumpedBricks;
	}
}

class CanBumpBricksHorizontaly{
	computeFuturePosition(moveable, dt, terrain){}
	
	reactToNewPosition(moveable, dt, terrain){
		let bumpedBricks = this.getBumpedBricks(moveable, terrain);
		if (bumpedBricks.length > 0)
			terrain.bumpBrick(bumpedBricks, moveable);
	}

	getBumpedBricks(moveable, terrain){
		let x1 = Math.floor((moveable.x + moveable.collisionPoints[CollisionPoints.TopLeft].x - 2.0) / terrain.tileWidth);
		let x2 = Math.floor((moveable.x + moveable.collisionPoints[CollisionPoints.TopRight].x + 2.0) / terrain.tileWidth);
	    let y  = Math.floor((moveable.y + moveable.collisionPoints[CollisionPoints.TopRight].y) / terrain.tileHeight);

		let bumpedBricks = [];
		if (terrain.isBumpable(x1, y)){
			bumpedBricks.push({x:x1, y:y});
		}
		
		if (x1 != x2 && terrain.isBumpable(x2, y)){
			bumpedBricks.push({x:x2, y:y});
		}

		return bumpedBricks;
	}
}

class AvoidsCliffs{
	computeFuturePosition(moveable, dt, terrain){}
	
	reactToNewPosition(moveable, dt, terrain){
		let isLeftFootOnAir  = terrain.getPointCollisonDistance(moveable.x + moveable.collisionPoints[0].x, moveable.y + moveable.collisionPoints[0].y, 0.0, 1.0, 2.0, false) > 1.0;
		let isRightFootOnAir = terrain.getPointCollisonDistance(moveable.x + moveable.collisionPoints[1].x, moveable.y + moveable.collisionPoints[1].y, 0.0, 1.0, 2.0, false) > 1.0;

		if (moveable.isTouchingGround && isLeftFootOnAir){
			moveable.dx = Math.abs(moveable.dx);
		}

		if (moveable.isTouchingGround && isRightFootOnAir){
			moveable.dx = -Math.abs(moveable.dx);
		}
	}
}

class AnimationBehavior{
	constructor(startFrame, numFrames, frameDuration){
		this.animation = new Animation(numFrames, frameDuration);
		this.startFrame = startFrame;
	}

	changeSpeed(frameDuration){
		this.animation.transitionTime = frameDuration;
	}

	reset(startFrame, numFrames, frameDuration){
		this.animation.transitionTime = frameDuration;
		this.startFrame = startFrame;
		this.animation.frame = 0;
		this.animation.frames = numFrames;
	}

	computeFuturePosition(moveable, dt, terrain){
		this.animation.update(dt);
		moveable.frame = this.animation.frame + this.startFrame;
	}
	
	reactToNewPosition(moveable, dt, terrain){}
}

class AlarmBehavior{
	constructor(delay, name){
		this.delay = delay;
		this.name = name;
		this.timeElapsed = 0;
	}

	computeFuturePosition(moveable, dt, terrain){		
		this.timeElapsed += dt;
		if (this.timeElapsed > this.delay){
			moveable.alarm(this.name)
		}
	}
	
	reactToNewPosition(moveable, dt, terrain){}
}

class MinimumX{
	constructor(x){
		this.minX = x;
	}
	computeFuturePosition(moveable, dt, terrain){		
		if (moveable.futureX < this.minX) moveable.futureX = this.minX;
	}
	
	reactToNewPosition(moveable, dt, terrain){}
}

class MaximumX{
	constructor(x){
		this.maxX = x;
	}
	computeFuturePosition(moveable, dt, terrain){		
		if (moveable.futureX > this.maxX) moveable.futureX = this.maxX;
	}
	
	reactToNewPosition(moveable, dt, terrain){}
}

class HasFriction{
	computeFuturePosition(moveable, dt, terrain){}
	
	reactToNewPosition(moveable, dt, terrain){
		moveable.isTouchingGround = terrain.getMultipointCollisionDistance(moveable.x, moveable.y, 0.0,  1.0, 2.0, moveable.collisionPoints) <= 1.0 || moveable.isStandingOnSolid;

		if (Math.abs(moveable.dx) > 0.001 && moveable.isTouchingGround){
			moveable.dx = moveable.dx * 0.97;
		}
	}
}

class Mario extends Moveable{
	constructor(x,y,dx,dy){
		super(x,y,dx,dy);
		this.smallCollisionPoints = [
			{x:-26, y:  0}, 
			{x: 26, y:  0},
			{x:-26, y:-50}, 
			{x: 26, y:-50},
			{x:-26, y:-25}, 
			{x: 26, y:-25},
		];
		this.bigCollisionPoints = [
			{x:-26, y:  0}, 
			{x: 26, y:  0},
			{x:-26, y:-78}, 
			{x: 26, y:-78},
			{x:-26, y:-39}, 
			{x: 26, y:-39},
		];
		this.collisionPoints = this.smallCollisionPoints;
		this.animation = new AnimationBehavior(0,1,250);
		this.behaviours = [new RespectsTerrain(), new CanBumpBricksAbove(), new MinimumX(30), new MaximumX(179*60-30), this.animation];
		this.facing = 1;
		this.direction = Directions.Idle;
		this.size = 0;
		this.isJumpPressed = false;
		this.isRunning = false;
	}

	collidesWith(other){
		if (other.state == States.Dead || other.state == States.Dying) return;

		if (other.state == States.Collectable) {
			other.collect(this);
			return;
		}

		let relativeLocation = this.getRelativeLocationTo(other);

		if (other.state == States.Solid) {
			if (this.dy > 0 && relativeLocation.above){
				this.dy = 0.0;
				this.futureY = this.y;
				this.isStandingOnSolid = true;
			}

			if (this.dy < 0 && relativeLocation.below){
				this.dy = 0.0;
				this.futureY = this.y;
				this.isBumpingSolid = true;
				other.bump(this);
			}

			if (relativeLocation.left || relativeLocation.right){
				this.dx = 0.0;
				if (isNaN(this.x)){
					debugger;
				}
				this.futureX = this.x;
			}
			return;
		}
		
		if (relativeLocation.above){
			this.dy = this.isJumpPressed ? -1.02 : -0.7;
			other.stomp(this);
		}else{
			if (other.touch)
				other.touch(this);
		}
	}

	jump(){
		this.dy = this.isRunning ? -1.02 : -0.9;
		sound.jump.play();
	}

	setJumpPressed(value){
		this.isJumpPressed = value;
		if (!value && this.dy < -0.6){
			this.dy = -0.6;
		}
	}

	grow(){
		this.size = 1;
		this.collisionPoints = this.bigCollisionPoints;
	}

	flower(){
		this.size = 2;
		this.collisionPoints = this.bigCollisionPoints;
	}

	shrink(){
		this.size = 0;
		this.collisionPoints = this.smallCollisionPoints;
	}

	setDirection(direction, running){	
		if (direction != Directions.Idle){
			this.facing = direction == Directions.Left ? 0 : 1;
		}

		if (direction != this.direction){
			if (direction != Directions.Idle){
				this.animation.reset(0,2,250); //walking
			}else{
				this.animation.reset(0,1,250); //standing
			}
		}

		if (running){
			this.animation.changeSpeed(125);
		}else{
			this.animation.changeSpeed(250);
		}

		this.dx = 0.2 * direction * (running ? 2 : 1);

		this.direction = direction;
		this.isRunning = running;
	}
}

class Goomba extends Moveable{
	constructor(x,y,dx,dy){		
		super(x,y,dx,dy);
		this.state = States.Walking;
		this.collisionPoints = [
			{x:  4, y:  0}, 
			{x: 56, y:  0},
			{x:  4, y:-41}, 
			{x: 56, y:-41},
		];

		this.behaviours = [new RespectsTerrain(), new ChangesDirectionWhenHittingWalls(), new AnimationBehavior(0,2,300)];		
	}

	collidesWith(other){
		if (this.state == States.Dead || this.state == States.Dying || other.state == States.Dead || other.state == States.Dying || other.state == States.Collectable) return;
		
		if (other.state == States.Spinning){
			this.wipe();
			return;
		}

		let relativeLocation = this.getRelativeLocationTo(other);
		if (relativeLocation.above){
			this.dy = 0;
			this.futureY = this.y;
		}else if (relativeLocation.left || relativeLocation.right){
			this.dx = -this.dx;
			this.futureX = this.x;			
		}
	}

	stomp(mario){
		this.state = States.Dying;		
		this.behaviours = [new AlarmBehavior(1000, "CleanupCorpse")];
		this.frame = 2;
		sound.stomp.play();
	}

	wipe(){
		this.state = States.Dying;		
		this.behaviours = [new IgnoresTerrain()];
		this.frame = 3;
		this.dy = -0.5;
		sound.kick.play();
	}

	alarm(name){
		if (name == "CleanupCorpse"){
			this.state = States.Dead;
		}
	}
}

class Koopa extends Moveable{
	constructor(x,y,dx,dy){
		super(x,y,dx,dy);
		this.collisionPoints = [
			{x:  4, y:  0}, 
			{x: 56, y:  0},
			{x:  4, y:-41}, 
			{x: 56, y:-41},
		];
		this.walk();
	}

	collidesWith(other){
		if (this.state == States.Dead || other.state == States.Dead || other.state == States.Dying || other.state == States.Collectable) return;

		if (other.state == States.Spinning){
			this.wipe();
		}

		let relativeLocation = this.getRelativeLocationTo(other);
		if ((relativeLocation.left || relativeLocation.right) && this.state != States.Spinning){
			this.dx = -this.dx;
			this.futureX = this.x;			
		}
		if (relativeLocation.above){
			this.dy = 0;
			this.futureY = this.y;
		}
	}

	wipe(){
		this.state = States.Dying;		
		this.behaviours = [new IgnoresTerrain()];
		this.frame = 3;
		this.dy = -0.5;
		sound.kick.play();
	}

	stomp(mario){
		if (this.state == States.Walking){
			this.cower();
		}else if (this.state == States.Cowering){
			this.kick(mario);
		}else if(this.state == States.Spinning){
			this.cower();
		}
	}

	touch(mario){
		if (this.state == States.Cowering){
			this.kick(mario);
		}
	}

	walk(){
		this.state = States.Walking;
		this.behaviours = [new RespectsTerrain(), new ChangesDirectionWhenHittingWalls(), new AnimationBehavior(0,2,300)];
	}

	cower(){
		this.state = States.Cowering;
		this.dx = 0.1 * Math.sign(this.dx);
		this.behaviours = [new AlarmBehavior(3000, "Shake")];
		this.frame = 3;
		sound.stomp.play();
	}

	kick(mario){
		this.behaviours = [new RespectsTerrain(), new ChangesDirectionWhenHittingWalls(), new AnimationBehavior(2,3,75), new CanBumpBricksHorizontaly()];
		this.dx = 0.3 * (mario.futureX < this.x) ? 1 : -1;
		this.state = States.Spinning;
		sound.kick.play();
	}

	shake(){
		this.behaviours = [new AnimationBehavior(2,3,100), new AlarmBehavior(500, "Emerge")];
	}

	alarm(name){
		if (name == "Shake"){
			this.shake();
		}else if (name == "Emerge"){
			this.walk();
		}
	}
}

class RedKoopa extends Koopa{
	constructor(x,y,dx,dy){
		super(x,y,dx,dy);
	}

	walk(){
		this.state = States.Walking;
		this.behaviours = [new RespectsTerrain(), new ChangesDirectionWhenHittingWalls(), new AvoidsCliffs(), new AnimationBehavior(0,2,300)];
	}
}

class Coin extends Moveable{
	constructor(x,y,dx,dy){
		super(x,y,dx,dy);
		this.collisionPoints = [
		{x: 10, y: 40},	
		{x: 51, y: 40},
		{x: 10, y:  0}, 
		{x: 51, y:  0}			
		];
		this.behaviours = [];
		this.state = States.Collectable;
	}
	
	collect(mario){
		sound.coin.play();
		this.state = States.Dead;
	}

	collidesWith(other){
		if (this.state == States.Dead || other.state == States.Dead || other.state == States.Dying) return;
	}
}

class Mushroom extends Moveable{
	constructor(x,y,dx,dy){
		super(x,y,dx,dy);
		this.collisionPoints = [
		{x:  1, y: 40},	
		{x: 59, y: 40},
		{x:  1, y:  0}, 
		{x: 59, y:  0}			
		];				
		this.state = States.Sprouting;		
		this.behaviours = [new AnimationBehavior(0,42,12), new AlarmBehavior(500, "BecomeCollectable")];
	}
	
	becomeCollectable(){
		this.state = States.Collectable;
		this.behaviours = [new RespectsTerrain(), new ChangesDirectionWhenHittingWalls()];
		this.frame = 42;
		this.dy = -0.3;
	}

	collect(mario){		
		sound.powerup.play();
		this.state = States.Dead;
		if (mario.size == 0){
			mario.grow();
		}
	}

	collidesWith(other){
		if (this.state == States.Dead || other.state == States.Dead || other.state == States.Dying) return;
	}

	alarm(name){
		if (name == "BecomeCollectable"){
			this.becomeCollectable();
		}
	}
}

class Flower extends Moveable{
	constructor(x,y,dx,dy){
		super(x,y,dx,dy);
		this.collisionPoints = [
		{x: 0, y: 40},	
		{x: 60, y: 40},
		{x: 0, y:  0}, 
		{x: 60, y:  0}			
		];				
		this.state = States.Sprouting;		
		this.behaviours = [new AnimationBehavior(0,42,12), new AlarmBehavior(500, "BecomeCollectable")];
	}
	
	becomeCollectable(){
		this.state = States.Collectable;
		this.behaviours = [];
		this.frame = 42;
		this.dy = -0.3;
	}

	collect(mario){		
		sound.powerup.play();
		this.state = States.Dead;
		mario.flower();
	}

	collidesWith(other){
		if (this.state == States.Dead || other.state == States.Dead || other.state == States.Dying) return;
	}

	alarm(name){
		if (name == "BecomeCollectable"){
			this.becomeCollectable();
		}
	}
}

class Brick extends Moveable{
	constructor(x,y,dx,dy){
		super(x,y,dx,dy);
		this.collisionPoints = [
		{x:  0, y: 42},
		{x: 60, y: 42},
		{x:  0, y:  0}, 
		{x: 60, y:  0}			
		];
		this.behaviours = [];
		this.state = States.Solid;
	}
	
	collect(mario){

	}

	bump(mario){
		sound.break.play();
		this.state = States.Dead;
	}

	collidesWith(other){
		if (this.state == States.Dead || other.state == States.Dead || other.state == States.Dying) return;

		if (other.state == States.Spinning){
			sound.break.play();
			this.state = States.Dead;
		}
	}
}

class BrickParticle extends Moveable{
	constructor(x,y,dx,dy){
		super(x,y,dx,dy);
		this.collisionPoints = [
		{x:  0, y: 18},
		{x: 18, y: 18},
		{x:  0, y:  0}, 
		{x: 18, y:  0}			
		];
		this.behaviours = [new RespectsTerrain(), new HasFriction(0.1), new AlarmBehavior(2000, "Vanish")];
		this.state = States.Dying;
	}
	collidesWith(other){}

	alarm(name){
		if (name == "Vanish"){
			this.state = States.Dead;
		}
	}
}

class Game{
	constructor(gfx, controls){
		this.gfx = gfx;
		this.controls = controls;
		this.frame = 0;
		this.treeAnimation = new Animation(3, 500);
		this.coinAnimation = new Animation(3, 333);
		this.turtleAnimation = new Animation(2, 300);
		
		this.screenX = 0;
		this.screenPan = 360;
		this.level = parseLevel();
		this.terrain = new Terrain(this.level, this);
		this.skyGradient = gfx.createBlueSkyGradient();
		this.mario = new Mario(360, 461, 0.0, 0.0);
		this.enemies = [];

		this.performance = [];
		this.perfIndex = 0;
		this.spawnEnemies();
	}
	
	update(time){
	    let dt = time - (this.prevTime ?? time);
	    this.prevTime = time;
				
		if (dt == 0 || dt > 1000) return;

		this.treeAnimation.update(dt);
		this.coinAnimation.update(dt);
		this.turtleAnimation.update(dt);
		
		this.updateEnemies(dt);

		this.frame = this.frame-2;
		if (this.frame <=0) this.frame = 41;			
		
		let direction = this.controls.direction;
		
		if (this.controls.jump && this.mario.isTouchingGround){
			this.mario.jump();
		}

		this.mario.setJumpPressed(this.controls.jump);

		this.mario.setDirection(this.controls.direction, this.controls.run);

		if (this.controls.pan != Directions.Idle){
			this.screenPan += Math.round((this.controls.pan == Directions.Left ? 1: -1) * dt * 0.3);

			//clip mario camera offset to 200 pixels off each side of the screen
			if (this.screenPan < 200) this.screenPan = 200;
			if (this.screenPan > 21 * 60 - 200) this.screenPan = 21 * 60 - 200;
		}

		if (this.mario.y > 42*14) { //mario fell off screen
			this.mario.y = 0;
			sound.die.play();
		}

		this.screenX = Math.floor(this.mario.x) - this.screenPan;

		//Clip screen X to the level size
		if (this.screenX > 60 * (this.level.length-21)) this.screenX = 60 * (this.level.length-21); //21 visible tiles
		if (this.screenX < 0) this.screenX = 0;

		let screenOffset = ((this.screenX % 60)+60)%60; //+60) % 60 solves the negative modulo jump issue
		let tileOffset = Math.floor(this.screenX / 60);
		
		this.spawnEnemies();

		this.performance[this.perfIndex] = dt;
		this.perfIndex = (this.perfIndex + 1) % 40;

		this.gfx.ctx.fillStyle = this.skyGradient;		
		this.gfx.ctx.fillRect(0, 0, 1200, 546);
		this.gfx.ctx.fillStyle = "black";
		let txtx = 10;
		for (let m of this.performance){
			this.gfx.ctx.fillText(m.toFixed(0), txtx, 50);
			txtx += 20;
		}

		if ((this.controls.debug % 3) < 2){
			this.drawTerrain(dt);
			this.drawEnemies();
			this.gfx.drawMario(this.mario.x - this.screenX - 30, this.mario.y - 83, this.mario.frame, this.mario.size, this.mario.facing);
		}
		if ((this.controls.debug % 3) > 0){
			this.drawDebug(dt);
		}

		this.controls.draw(this.gfx);
	}

	spawnEnemies(){
		let tileOffset = Math.floor(this.screenX / 60);
		for (let x=0; x<21;++x){
		    if (x+tileOffset < 0) continue;
			if (x+tileOffset >= this.level.length-1) break;
			for (let y=0; y<13;++y){
				let tileId = this.level[x+tileOffset][y];
				if (tileId == 103+8){
					let goomba = new Goomba(60 * (x+tileOffset),42*y+41,-0.1,0.0);
					this.enemies.push(goomba);
					this.level[x+tileOffset][y] = 255;
				}else if (tileId == 104+8){
					let koopa = new Koopa(60 * (x+tileOffset),42*y+41,-0.1,0.0);
					this.enemies.push(koopa);
					this.level[x+tileOffset][y] = 255;
				}else if (tileId == 105+8){
					let koopa = new RedKoopa(60 * (x+tileOffset),42*y+41,-0.1,0.0);
					this.enemies.push(koopa);
					this.level[x+tileOffset][y] = 255;
				}else if (tileId == 101+8){
					let coin = new Coin(60 * (x+tileOffset),42 * y, 0.0, 0.0);
					this.enemies.push(coin);
					this.level[x+tileOffset][y] = 255;
				}else if (tileId == 107+8){
					//let mushroom = new Mushroom(60 * (x+tileOffset),42 * y, 0.1, 0.0);
					//this.enemies.push(mushroom);
					//this.level[x+tileOffset][y] = 255;
				}else if (tileId == 9){
					//let brick = new Brick(60 * (x+tileOffset),42 * y, 0.0, 0.0);
					//this.enemies.push(brick);
					//this.level[x+tileOffset][y] = 255;
				}
			}
		}
	}

	checkEnemiesCollisions(){		
		this.enemies = this.enemies.filter((e)=>e.y < 1000 && e.state != States.Dead);
		
		for (let i = 0; i < this.enemies.length - 1; i++) {
			for (let j = i + 1; j < this.enemies.length; j++) {
				let distance = this.enemies[i].getDistanceFromOtherMoveable(this.enemies[j]);
				if (distance.dx < 0 && distance.dy < 0){
					this.enemies[i].collidesWith(this.enemies[j]);
					this.enemies[j].collidesWith(this.enemies[i]);
				}
			}
    	}
	}

	updateEnemies(dt){
		this.mario.calculateFuturePosition(dt, this.terrain, this.enemies);
		
		for (let e of this.enemies){
			e.calculateFuturePosition(dt, this.terrain, this.enemies);

			let distance = this.mario.getDistanceFromOtherMoveable(e);
				if (distance.dx < 0 && distance.dy < 0){
					this.mario.collidesWith(e);
				}
		}
		
		this.checkEnemiesCollisions();

		for (let e of this.enemies){
			e.applyPosition(dt, this.terrain, this.enemies);
		}		
		this.mario.applyPosition(dt, this.terrain, this.enemies);
	}

	drawEnemies(){
		for (let e of this.enemies){
			if (e.constructor.name == "Goomba"){
				this.gfx.drawGoomba(e.x - this.screenX, e.y, e.frame, 0);
			}else if (e.constructor.name == "Koopa"){
				this.gfx.drawTurtle(e.x - this.screenX, e.y, e.frame, 0, e.dx > 0 ? 1 : 0);
			}else if (e.constructor.name == "RedKoopa"){
				this.gfx.drawTurtle(e.x - this.screenX, e.y, e.frame, 1, e.dx > 0 ? 1 : 0);
			}else if (e.constructor.name == "Coin"){
				this.gfx.drawCoin(e.x - this.screenX, e.y, this.coinAnimation.frame); //All coins use same frame so that glares are aligned
			}else if (e.constructor.name == "Mushroom"){
				this.gfx.drawMushroom(e.x - this.screenX, e.y, e.frame, 0);
			}else if (e.constructor.name == "Flower"){
				this.gfx.drawMushroom(e.x - this.screenX, e.y, e.frame, 4);			
			}else if (e.constructor.name == "BrickParticle"){
				this.gfx.drawBrickParticle(e.x - this.screenX, e.y);				
			}else if (e.constructor.name == "Brick"){
				this.gfx.drawTileOld(e.x - this.screenX, e.y, 1);
			}
		}
	}

	drawTerrain(dt){
		let screenOffset = ((this.screenX % 60)+60)%60; //+60) % 60 solves the negative modulo jump issue
		let tileOffset = Math.floor(this.screenX / 60);
		for (let x=-2; x<21 +1;++x){
		    if (x+tileOffset < 0) continue;
			if (x+tileOffset >= this.level.length-1) break;
			for (let y=0; y<13;++y){
			   let tileId = this.level[x+tileOffset][y];
			   if (tileId != 255){				   				  
		           if (tileId == 101+8){
					  //this.gfx.drawCoin(60 * x - screenOffset, 42 * y + 16, this.coinAnimation.frame);
				   }else if (tileId == 102+8){
					  this.gfx.drawWeed(60 * x - screenOffset, 42 * y + 16, this.treeAnimation.frame);
				   }else if (tileId == 100+8){
					  this.gfx.drawTree(60 * x - screenOffset, 42 * y + 16, this.treeAnimation.frame);
				   }else if (tileId == 76+8){
					  this.gfx.drawWater(60 * x - screenOffset, 42*y+16, this.frame);
				   }else if (tileId < 8){
				     this.gfx.drawTile(60 * x - screenOffset, 42*y, tileId, 0);
                   }else if (tileId == 106+8){
					 this.gfx.drawWeed(60 * x - screenOffset, 42 * y + 16, this.treeAnimation.frame);
					 this.gfx.drawTileOld(60 * x - screenOffset, 42*y, 9);
                   }else{
					
					let bumpY = 0;
					for(let b of this.terrain.bumpedBricks){
						if (b.x == x + tileOffset && b.y == y){
							if (!b.t){
								b.t = 0;
							}
							b.t += dt;
							bumpY = -Math.sin(b.t / 200 * Math.PI) * 10;
						}
					}					 					
				     this.gfx.drawTileOld(60 * x - screenOffset, 42*y + bumpY, tileId-8);
                   }				   
			   }
		   }
		}
		this.terrain.bumpedBricks = this.terrain.bumpedBricks.filter((b)=> (b.t ?? 0) < 200);
		//this.gfx.drawSpiney(60 * x - screenOffset, 42 * y + 16, this.turtleAnimation.frame, 1);
		//this.gfx.drawFish(60 * x - screenOffset, 42 * y + 16, this.turtleAnimation.frame, 1);
	}
	
	drawDebug(dt){
		let screenOffset = ((this.screenX % 60)+60)%60; //+60) % 60 solves the negative modulo jump issue
		let tileOffset = Math.floor(this.screenX / 60);
		//Draw Grid
		this.gfx.ctx.strokeStyle = "darkGray";
		for (let x=0; x<21;++x){
			this.gfx.ctx.beginPath();
	        this.gfx.ctx.moveTo(x * 60 - screenOffset, 0);
		    this.gfx.ctx.lineTo(x * 60 - screenOffset, 13 * 42);
	        this.gfx.ctx.stroke();
		}
		for (let y=0; y<13;++y){
			this.gfx.ctx.beginPath();
	        this.gfx.ctx.moveTo(0,       y * 42);
		    this.gfx.ctx.lineTo(21 * 60, y * 42);
	        this.gfx.ctx.stroke();
		}

		//Draw Solid blocks
		this.gfx.ctx.strokeStyle = "red";
		for (let x=0; x<21;++x){
		    if (x+tileOffset < 0) continue;
			if (x+tileOffset >= this.level.length-1) break;
			for (let y=0; y<13;++y){
			   if (this.terrain.isSolid(x+tileOffset,y)){
				   this.gfx.ctx.strokeRect(x * 60 - screenOffset, y * 42, 60, 42);
			   }
		    }
		}
		
		//Draw mario direction
		this.gfx.ctx.strokeStyle = "green";
		this.gfx.ctx.beginPath();
        this.gfx.ctx.moveTo(this.mario.x - this.screenX, this.mario.y);
	    this.gfx.ctx.lineTo(this.mario.x + this.mario.dx * dt * 5 - this.screenX, this.mario.y + this.mario.dy * dt * 5);
        this.gfx.ctx.stroke();
		//Draw mario location
		this.gfx.ctx.beginPath();
		this.gfx.ctx.arc(this.mario.x - this.screenX,this.mario.y, 5, 0, 2 * Math.PI);
		this.gfx.ctx.stroke();
		//Draw Mario collison points
		for (let p of this.mario.collisionPoints){
			this.gfx.ctx.beginPath();
			this.gfx.ctx.arc(this.mario.x - this.screenX + p.x, this.mario.y + p.y, 3, 0, 2 * Math.PI);
			this.gfx.ctx.stroke();
		}

		for (let e of this.enemies){
			for (let p of e.collisionPoints){
				this.gfx.ctx.beginPath();
				this.gfx.ctx.arc(e.x - this.screenX + p.x, e.y + p.y, 3, 0, 2 * Math.PI);
				this.gfx.ctx.stroke();
			}	
		}
	}
}

var gGame;
function initGame(){
	var canvas = document.getElementById("MyCanvas");
	var ctx = canvas.getContext("2d");
	var graphics = new Graphics(ctx);

	var keyboard = new Keyboard(canvas);
	var touch = new Touch(canvas);
	var controls;

	if (navigator.userAgent.match(/Android/i)
         || navigator.userAgent.match(/webOS/i)
         || navigator.userAgent.match(/iPhone/i)
         || navigator.userAgent.match(/iPad/i)
         || navigator.userAgent.match(/iPod/i)
         || navigator.userAgent.match(/BlackBerry/i)
         || navigator.userAgent.match(/Windows Phone/i)) {
		controls = touch;
	} else {
		controls = keyboard;
	}
	
	var game = new Game(graphics, controls);
	setInterval(()=>window.requestAnimationFrame((time)=>game.update(time)), 16);
	gGame = game;
}
</script>
</head>
<body onload="initGame()">
   <canvas id="MyCanvas" width="1200" height="546" style="border:1px solid #000000; background-color:#5080A0;"></canvas>
</body>
</html>