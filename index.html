<!DOCTYPE html>‚Äù
<html>
<head>
<script src="graphics.js"></script>
<script src="levels.js"></script>
<script src="keyboard.js"></script>
<style>
html, body {
  margin: 0;
}
</style>

<script>
class Animation{
  constructor(frames, transitionTime){
     this.frames = frames; 
     this.transitionTime = transitionTime;
	 this.frame = 0;
	 this.t = 0;
  }
  
  update(dt){
     this.t = this.t + dt;
     this.frame = (this.frame + Math.floor(this.t / this.transitionTime)) % this.frames;
	 this.t = this.t > this.transitionTime ? this.t - this.transitionTime : this.t;
  }
  
}

class Terrain{
	constructor(tiles){
		this.tiles = tiles;
		this.tileWidth = 60;
		this.tileHeight = 42;
	}

	inBounds(X,Y){
		return X >= 0 && X < this.tiles.length && Y >= 0 && Y < this.tiles[X].length;
	}

	isSolid(X,Y){
		return this.inBounds(X,Y) && (this.tiles[X][Y] < 8 || [9,20,26,27,32,33,67].includes(this.tiles[X][Y]));
	}

	getPointCollisonDistance(x, y, dx, dy, tMax, wantNonSolid){		
        //Ref: A fast voxel traversal algorithm J.Amanatides, A. Woo      
		//(x,y) the location of the point. 
		//(dx, dy) the normalized speed of the point in pixels per second. 
		//tMax the number of seconds the point intents to travel

        //Distance in seconds between two consecutive lines when moving at direction (dx,dy)
        let tVertical    = this.tileWidth  / Math.abs(dx);
        let tHorizontal  = this.tileHeight / Math.abs(dy);

        //Starting Tile location
        let X = Math.floor(x / this.tileWidth);
        let Y = Math.floor(y / this.tileHeight);

		//Ending Tile location
        let endX = Math.floor((x + dx * tMax) / this.tileWidth);
        let endY = Math.floor((y + dy * tMax) / this.tileHeight);

		let tNextVertical, tNextHorizontal; //The distance in seconds to the next line
        let stepX, stepY;                   //The direction we move across tiles        

        if (dx >= 0.0){
            stepX = 1;
            tNextVertical = ((X+1) * this.tileWidth - x) / dx;
        }else{
            stepX = -1;
            tNextVertical = (X * this.tileWidth - x) / dx;
        }

        if (dy >= 0.0){
            stepY = 1;
            tNextHorizontal = ((Y+1) * this.tileHeight - y) / dy;
        }else{
            stepY = -1;
            tNextHorizontal = (Y * this.tileHeight - y) / dy;
        }

        if (this.isSolid(X, Y) && !wantNonSolid) {
			//this tries to solve the problem if mario happens to be inside a solid block.
			//the idea is to flip the direction and call the inverse of this function to find the first non-solid
            return this.getPointCollisonDistance(x,y,-dx,-dy, 10000, true); 
        }

        let t = 0.0;
        while ((X != endX || Y !=endY) && (t < tMax)){
            if(tNextVertical < tNextHorizontal){
                t = tNextVertical;
                tNextVertical += tVertical;
                X += stepX;

				if (this.isSolid(X, Y) ^ wantNonSolid) {
					if (!wantNonSolid){
                		return t - stepX / dx; //Return t at one pixel before the collision with the solid vertical line
					} else {
						return t + stepX / dx; //Return t at one pixel after the collision with the non-solid vertical line
					}
				}
            }else{
                t = tNextHorizontal;
                tNextHorizontal += tHorizontal;
                Y += stepY;

				if (this.isSolid(X, Y) ^ wantNonSolid) {
					if (!wantNonSolid){
                		return t - stepY / dy; //Return t at one pixel before the collision with the vertical line
					} else {
						return t + stepY / dy;
					}
				}
            }
        }
        return tMax;
    }
}

class Mario{
	constructor(x, y, dx, dy){
		this.x = x;     //in pixels
		this.y = y;     //in pixels
		this.dx = dx;   //in pixels per millisecond
		this.dy = dy;   //in pixels per millisecond
		this.ay = 0.04;  //in pixels per millisecond per millisecond
		this.dyTerminal = 1.0; //in pixels per millisecond
		this.isMarioTouchingGround = false;
	}

	update(dt, terrain){
		let tDiagonal = terrain.getPointCollisonDistance(this.x, this.y, this.dx, this.dy, dt, false);
		this.x = this.x + this.dx * tDiagonal;
		this.y = this.y + this.dy * tDiagonal;
		//check if mario can move stricly in dx or dy for the remainder of the distance
		let tHorizontal = terrain.getPointCollisonDistance(this.x, this.y, this.dx, 0.0, dt - tDiagonal, false);
		this.x = this.x + this.dx * tHorizontal;		
		let tVertical = terrain.getPointCollisonDistance(this.x, this.y, 0.0, this.dy, dt - tDiagonal, false);
		this.y = this.y + this.dy * tVertical;
		
		this.isTouchingGround = terrain.getPointCollisonDistance(this.x, this.y, 0.0, 1.0, 1.0, false) < 1.0;
		
		if (!this.isTouchingGround)
			this.dy = Math.min(this.dy + this.ay, this.dyTerminal);
		else
			this.dy = 0.0;
	}
}

class Game{
	constructor(gfx, controls){
		this.gfx = gfx;
		this.controls = controls;
		this.frame = 0;
		this.treeAnimation = new Animation(3, 500);
		this.coinAnimation = new Animation(3, 333);
		this.turtleAnimation = new Animation(2, 300);
		
		this.screenX = 0;
		this.level = parseLevel();
		this.terrain = new Terrain(this.level);
		this.skyGradient = gfx.createBlueSkyGradient();
		this.lastFacing = 1;
		this.mario = new Mario(200,10,0.0,0.08);
	}
	
	update(time){
	    let dt = time - (this.prevTime ?? time);
	    this.prevTime = time;
		if (dt > 1000) return;
		this.treeAnimation.update(dt);
		this.coinAnimation.update(dt);
		this.turtleAnimation.update(dt);
		this.mario.update(dt, this.terrain);

		this.frame = this.frame-2;
		if (this.frame <=0) this.frame = 41;
		//this.gfx.ctx.clearRect(0, 0, 1200, 546);
		
		this.gfx.ctx.fillStyle = this.skyGradient;
		this.gfx.ctx.fillRect(0, 0, 1200, 546);
				
		
		let direction = this.controls.getDirection();
		
		if (this.controls.wantJump() && this.mario.isTouchingGround){
			this.mario.dy = -1;
		}

		let facing = this.lastFacing;
		if (direction !=0){
			facing = direction == 1 ? 1 : 0;			
			this.lastFacing = facing;			
		}

		this.mario.dx = 0.2 * direction;

		this.screenX = Math.floor(this.mario.x) - 200;
		let screenOffset = ((this.screenX % 60)+60)%60; //+60) % 60 solves the negative modulo jump issue
		let tileOffset = Math.floor(this.screenX / 60);
		
		//Draw tiles
		for (let x=0; x<21;++x){
		    if (x+tileOffset < 0) continue;
			if (x+tileOffset >= this.level.length-1) break;
			for (let y=0; y<13;++y){
			   let tileId = this.level[x+tileOffset][y];
			   if (tileId != 255){				   				  
		           if (tileId == 101+8){
					  this.gfx.drawCoin(60 * x - screenOffset, 42 * y + 16, this.coinAnimation.frame);
				   }else if (tileId == 102+8){
					  this.gfx.drawWeed(60 * x - screenOffset, 42 * y + 16, this.treeAnimation.frame);
				   }else if (tileId == 103+8){
					  this.gfx.drawGoomba(60 * x - screenOffset, 42 * y + 16, this.turtleAnimation.frame,0);
				   }else if (tileId == 104 +8|| tileId == 105+8){
					  //this.gfx.drawTurtle(60 * x - screenOffset, 42 * y + 16, this.turtleAnimation.frame, 1-(tileId - 104),0);
					  //this.gfx.drawShell(60 * x - screenOffset, 42 * y + 16, this.turtleAnimation.frame, 1-(tileId - 104),0);
					  //this.gfx.drawSpiney(60 * x - screenOffset, 42 * y + 16, this.turtleAnimation.frame, 1);
					  //this.gfx.drawFish(60 * x - screenOffset, 42 * y + 16, this.turtleAnimation.frame, 1);
				   }else if (tileId == 100+8){
					  this.gfx.drawTree(60 * x - screenOffset, 42 * y + 16, this.treeAnimation.frame);
				   }else if (tileId == 13+8){
					  this.gfx.drawWater(60 * x - screenOffset, 42*y+16, this.frame);
				   }else if (tileId < 8){
				     this.gfx.drawTile(60 * x - screenOffset, 42*y, tileId, 0);
                   }else{
				     this.gfx.drawTileOld(60 * x - screenOffset, 42*y, tileId-8);
                   }				   
			   }
		   }
		}

		//Draw Mario
		this.gfx.drawMario(this.mario.x - this.screenX - 30,this.mario.y - 83,direction != 0 ? this.turtleAnimation.frame : 0,0,facing);

		//Draw Grid
		this.gfx.ctx.strokeStyle = "darkGray";
		for (let x=0; x<21;++x){
			this.gfx.ctx.beginPath();
	        this.gfx.ctx.moveTo(x * 60 - screenOffset, 0);
		    this.gfx.ctx.lineTo(x * 60 - screenOffset, 13*42);
	        this.gfx.ctx.stroke();
		}
		for (let y=0; y<13;++y){
			this.gfx.ctx.beginPath();
	        this.gfx.ctx.moveTo(0, y*42);
		    this.gfx.ctx.lineTo(21 * 60, y*42);
	        this.gfx.ctx.stroke();
		}

		//Draw Solid blocks
		this.gfx.ctx.strokeStyle = "red";
		for (let x=0; x<21;++x){
		    if (x+tileOffset < 0) continue;
			if (x+tileOffset >= this.level.length-1) break;
			for (let y=0; y<13;++y){
			   if (this.terrain.isSolid(x+tileOffset,y)){
				   this.gfx.ctx.strokeRect(x * 60 - screenOffset, y*42, 60,42);
			   }
		    }
		}
		
		//Draw mario direction
		this.gfx.ctx.strokeStyle = "green";
		this.gfx.ctx.beginPath();
        this.gfx.ctx.moveTo(this.mario.x - this.screenX, this.mario.y);
	    this.gfx.ctx.lineTo(this.mario.x + this.mario.dx * dt * 5 - this.screenX, this.mario.y + this.mario.dy * dt * 5);
        this.gfx.ctx.stroke();
		//Draw mario location
		this.gfx.ctx.beginPath();
		this.gfx.ctx.arc(this.mario.x - this.screenX,this.mario.y, 5, 0, 2 * Math.PI);
		this.gfx.ctx.stroke();

	}
}

function initGame(){
	var canvas = document.getElementById("MyCanvas");
	var ctx = canvas.getContext("2d");
	var graphics = new Graphics(ctx);
	var keyboard = new Keyboard();
	var game = new Game(graphics, keyboard);
	setInterval(()=>window.requestAnimationFrame((time)=>game.update(time)), 16);
}
</script>
</head>
<body onload="initGame()">
   <canvas id="MyCanvas" width="1200" height="546" style="border:1px solid #000000; background-color:#5080A0;"></canvas>
</body>
</html>