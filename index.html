<!DOCTYPE html>‚Äù
<html>
<head>
<meta name="apple-mobile-web-app-capable" content="yes">
<script src="graphics.js"></script>
<script src="levels.js"></script>
<script src="keyboard.js"></script>
<script src="touch.js"></script>
<script src="sound.js"></script>
<style>
html, body {
  margin: 0;
}
</style>

<script>
class Animation{
  constructor(frames, transitionTime){
     this.frames = frames; 
     this.transitionTime = transitionTime;
	 this.frame = 0;
	 this.t = 0;
  }
  
  update(dt){
     this.t = this.t + dt;
     this.frame = (this.frame + Math.floor(this.t / this.transitionTime)) % this.frames;
	 this.t = this.t > this.transitionTime ? this.t - this.transitionTime : this.t;
  }
  
}

function noNaN(x){
	if (isNaN(x))
		return 0;
	return x;
}
	
class Terrain{
	constructor(tiles){
		this.tiles = tiles;
		this.tileWidth = 60;
		this.tileHeight = 42;
	}

	inBounds(X,Y){
		return X >= 0 && X < this.tiles.length && Y >= 0 && Y < this.tiles[X].length;
	}

	isSolid(X,Y){
		return this.inBounds(X,Y) && (this.tiles[X][Y] < 8 || [9,20,26,27,32,33,67].includes(this.tiles[X][Y]));
	}
	
	getPointCollisonDistance(x, y, dx, dy, tMax, wantNonSolid){		
        //Ref: A fast voxel traversal algorithm J.Amanatides, A. Woo      
		//(x,y) the location of the point. 
		//(dx, dy) the normalized speed of the point in pixels per second. 
		//tMax the number of seconds the point intents to travel

        //Distance in seconds between two consecutive lines when moving at direction (dx,dy)
        let tVertical    = this.tileWidth  / Math.abs(dx);
        let tHorizontal  = this.tileHeight / Math.abs(dy);

        //Starting Tile location
        let X = Math.floor(x / this.tileWidth);
        let Y = Math.floor(y / this.tileHeight);

		//Ending Tile location
        let endX = Math.floor((x + dx * tMax) / this.tileWidth);
        let endY = Math.floor((y + dy * tMax) / this.tileHeight);

		let tNextVertical, tNextHorizontal; //The distance in seconds to the next line
        let stepX, stepY;                   //The direction we move across tiles        

        if (dx >= 0.0){
            stepX = 1;
            tNextVertical = ((X+1) * this.tileWidth - x) / dx;
        }else{
            stepX = -1;
            tNextVertical = (X * this.tileWidth - x) / dx;
        }

        if (dy >= 0.0){
            stepY = 1;
            tNextHorizontal = ((Y+1) * this.tileHeight - y) / dy;
        }else{
            stepY = -1;
            tNextHorizontal = (Y * this.tileHeight - y) / dy;
        }

		if (isNaN(tNextVertical) || isNaN(tNextHorizontal)){
			debugger;
		}

        if (this.isSolid(X, Y) && !wantNonSolid) {
			//this tries to solve the problem if mario happens to be inside a solid block.
			//the idea is to flip the direction and call the inverse of this function to find the first non-solid
            return this.getPointCollisonDistance(x,y,-dx,-dy, 10000, true); 
        }

        let t = 0.0;
        while ((X != endX || Y !=endY) && (t < tMax)){
            if(tNextVertical < tNextHorizontal){
                t = tNextVertical;
                tNextVertical += tVertical;
                X += stepX;

				if (this.isSolid(X, Y) ^ wantNonSolid) {
					if (!wantNonSolid){
                		return t - noNaN(stepX / dx); //Return t at one pixel before the collision with the solid vertical line
					} else {
						return t + noNaN(stepX / dx); //Return t at one pixel after the collision with the non-solid vertical line
					}
				}
            }else{
                t = tNextHorizontal;
                tNextHorizontal += tHorizontal;
                Y += stepY;

				if (this.isSolid(X, Y) ^ wantNonSolid) {
					if (!wantNonSolid){
                		return t - noNaN(stepY / dy); //Return t at one pixel before the collision with the vertical line
					} else {
						return t + noNaN(stepY / dy);
					}
				}
            }
        }
        return tMax;
    }

	getMultipointCollisionDistance(x, y, dx, dy, tMax, collisionPoints){
		let minT = tMax;
		for (let p of collisionPoints){
			let t = this.getPointCollisonDistance(x + p.x, y + p.y, dx, dy, tMax, false);
			minT = Math.min(minT, t);
		}
		return minT;
	}
}

const States = {
	Idle: 0,
	Walking: 1,
	Cowering: 2,
	Spinning: 3,
	Dying: 4,
	Dead: 5
}


class Moveable{
	constructor(x, y, dx, dy){
		this.x = x;     //in pixels
		this.y = y;     //in pixels
		this.dx = dx;   //in pixels per millisecond
		this.dy = dy;   //in pixels per millisecond
		this.ay = 0.0025;  //in pixels per millisecond per millisecond
		this.dyTerminal = 1.0; //in pixels per millisecond
		this.isTouchingGround = false;
		this.isBumpingCeiling = false;
		this.collisionPoints = []; //The first four must be the corners: bottom-left, bottom-right, top-left, top-right 
		this.futureX = x; //in pixels
		this.futureY = y; //in pixels

		this.behaviours = [];
	}


	getRelativeLocationTo(other){
		let al = this.x + this.collisionPoints[0].x;
		let ar = this.x + this.collisionPoints[3].x;
		let at = this.y + this.collisionPoints[3].y;
		let ab = this.y + this.collisionPoints[0].y;

		let bl = other.x + other.collisionPoints[0].x;
		let br = other.x + other.collisionPoints[3].x;
		let bt = other.y + other.collisionPoints[3].y;
		let bb = other.y + other.collisionPoints[0].y;

		return {above: ab < bt, below: at > bb, left: ar < bl, right: al > br };
	}


	getDistanceFromOtherMoveable(other){
		let al = this.futureX + this.collisionPoints[0].x;
		let ar = this.futureX + this.collisionPoints[3].x;
		let at = this.futureY + this.collisionPoints[3].y;
		let ab = this.futureY + this.collisionPoints[0].y;

		let bl = other.futureX + other.collisionPoints[0].x;
		let br = other.futureX + other.collisionPoints[3].x;
		let bt = other.futureY + other.collisionPoints[3].y;
		let bb = other.futureY + other.collisionPoints[0].y;

		let dx1 = al - br;
		let dx2 = bl - ar;
		let dy1 = at - bb;
		let dy2 = bt - ab;

		return {dx: Math.max(dx1,dx2), dy: Math.max(dy1,dy2)};
	}

	calculateFuturePosition(dt, terrain){
		for (let b of this.behaviours){
			b.computeFuturePosition(this, dt, terrain);
		}
	}
	
	applyPosition(dt, terrain){
		this.x = this.futureX;
		this.y = this.futureY;

		for (let b of this.behaviours){
			b.reactToNewPosition(this, dt, terrain);
		}
	}
}

//Composable behaviors
class RespectsTerrain {
	computeFuturePosition(moveable, dt, terrain){
		let tDiagonal = terrain.getMultipointCollisionDistance(moveable.x, moveable.y, moveable.dx, moveable.dy, dt, moveable.collisionPoints);
		
		if (isNaN(tDiagonal)){
			debugger;
		}	

		let x = moveable.x + moveable.dx * tDiagonal;
		let y = moveable.y + moveable.dy * tDiagonal;
				
		//check if mario can move stricly in dx or dy for the remainder of the distance
		let tHorizontal = terrain.getMultipointCollisionDistance(x, y, moveable.dx, 0.0, dt - tDiagonal, moveable.collisionPoints);
		
		if (isNaN(tHorizontal)){
			debugger;
		}	

		x = x + moveable.dx * tHorizontal;	

		let tVertical = terrain.getMultipointCollisionDistance(x, y, 0.0, moveable.dy, dt - tDiagonal, moveable.collisionPoints);
		
		if (isNaN(tVertical)){
			debugger;
		}		

		y = y + moveable.dy * tVertical;
		
		moveable.futureX = x;
		moveable.futureY = y;
	}


	reactToNewPosition(moveable, dt, terrain){
		moveable.isTouchingGround = terrain.getMultipointCollisionDistance(moveable.x, moveable.y, 0.0,  1.0, 2.0, moveable.collisionPoints) <= 1.0;
		moveable.isBumpingCeiling = terrain.getMultipointCollisionDistance(moveable.x, moveable.y, 0.0, -1.0, 2.0, moveable.collisionPoints) <= 1.0;
		
		if (!moveable.isTouchingGround)
			moveable.dy = Math.min(moveable.dy + moveable.ay * dt, moveable.dyTerminal);
		else
			moveable.dy = 0.0;

		if (moveable.isBumpingCeiling && moveable.dy < 0.0)
			moveable.dy = 0.0;
	}
}

class IgnoresTerrain{
	computeFuturePosition(moveable, dt, terrain){
		moveable.futureX = moveable.x + moveable.dx * dt;
		moveable.futureY = moveable.y + moveable.dy * dt;
	}

	reactToNewPosition(moveable, dt, terrain){		
		moveable.dy = Math.min(moveable.dy + moveable.ay * dt, moveable.dyTerminal);		
	}
}

class ChangesDirectionWhenHittingWalls{
	computeFuturePosition(moveable, dt, terrain){}
	
	reactToNewPosition(moveable, dt, terrain){
		let isHittingLeftWall  = terrain.getMultipointCollisionDistance(moveable.x, moveable.y, -1.0, 0.0, 2.0, moveable.collisionPoints) <= 1.0;
		let isHittingRightWall = terrain.getMultipointCollisionDistance(moveable.x, moveable.y,  1.0, 0.0, 2.0, moveable.collisionPoints) <= 1.0;

		if (isHittingLeftWall && !isHittingRightWall){
			moveable.dx = Math.abs(moveable.dx);
		}
		if (!isHittingLeftWall && isHittingRightWall){
			moveable.dx = -Math.abs(moveable.dx);
		}
	}
}

class AvoidsCliffs{
	computeFuturePosition(moveable, dt, terrain){}
	
	reactToNewPosition(moveable, dt, terrain){
		let isLeftFootOnAir  = terrain.getPointCollisonDistance(moveable.x + moveable.collisionPoints[0].x, moveable.y + moveable.collisionPoints[0].y, 0.0, 1.0, 2.0, false) > 1.0;
		let isRightFootOnAir = terrain.getPointCollisonDistance(moveable.x + moveable.collisionPoints[1].x, moveable.y + moveable.collisionPoints[1].y, 0.0, 1.0, 2.0, false) > 1.0;

		if (moveable.isTouchingGround && isLeftFootOnAir){
			moveable.dx = Math.abs(moveable.dx);
		}

		if (moveable.isTouchingGround && isRightFootOnAir){
			moveable.dx = -Math.abs(moveable.dx);
		}
	}
}

class AnimationBehavior{
	constructor(startFrame, numFrames, frameDuration){
		this.animation = new Animation(numFrames, frameDuration);
		this.startFrame = startFrame;
	}

	computeFuturePosition(moveable, dt, terrain){
		this.animation.update(dt);
		moveable.frame = this.animation.frame + this.startFrame;
	}
	
	reactToNewPosition(moveable, dt, terrain){}
}

class AlarmBehavior{
	constructor(delay, name){
		this.delay = delay;
		this.name = name;
		this.timeElapsed = 0;
	}

	computeFuturePosition(moveable, dt, terrain){		
		this.timeElapsed += dt;
		if (this.timeElapsed > this.delay){
			moveable.alarm(this.name)
		}
	}
	
	reactToNewPosition(moveable, dt, terrain){}
}

class Mario extends Moveable{
	constructor(x,y,dx,dy){
		super(x,y,dx,dy);
		this.collisionPoints = [
			{x:-26, y:  0}, 
			{x: 26, y:  0},
			{x:-26, y:-50}, 
			{x: 26, y:-50},
			{x:-26, y:-25}, 
			{x: 26, y:-25},
		];

		this.behaviours = [new RespectsTerrain()];
	}

	collidesWith(other){
		if (other.state == States.Dead || other.state == States.Dying) return;
		let relativeLocation = this.getRelativeLocationTo(other);
		if (relativeLocation.above){
			this.dy = -1.1;
			other.stomp(this);
		}else{
			if (other.touch)
				other.touch(this);
		}
	}
}

class Goomba extends Moveable{
	constructor(x,y,dx,dy){		
		super(x,y,dx,dy);
		this.state = States.Walking;
		this.collisionPoints = [
			{x:  4, y:  0}, 
			{x: 56, y:  0},
			{x:  4, y:-41}, 
			{x: 56, y:-41},
		];

		this.behaviours = [new RespectsTerrain(), new ChangesDirectionWhenHittingWalls(), new AnimationBehavior(0,2,300)];		
	}

	collidesWith(other){
		if (this.state == States.Dead || this.state == States.Dying || other.state == States.Dead || other.state == States.Dying) return;

		if (other.state == States.Spinning){
			this.wipe();
			return;
		}

		let relativeLocation = this.getRelativeLocationTo(other);
		if (relativeLocation.above){
			this.dy = 0;
			this.futureY = this.y;
		}else if (relativeLocation.left || relativeLocation.right){
			this.dx = -this.dx;
			this.futureX = this.x;			
		}
	}

	stomp(mario){
		this.state = States.Dying;		
		this.behaviours = [new AlarmBehavior(1000, "CleanupCorpse")];
		this.frame = 2;
		sound.stomp.play();
	}

	wipe(){
		this.state = States.Dying;		
		this.behaviours = [new IgnoresTerrain()];
		this.frame = 3;
		this.dy = -0.5;
		sound.kick.play();
	}

	alarm(name){
		if (name == "CleanupCorpse"){
			this.state = States.Dead;
		}
	}
}

class Koopa extends Moveable{
	constructor(x,y,dx,dy){
		super(x,y,dx,dy);
		this.collisionPoints = [
			{x:  4, y:  0}, 
			{x: 56, y:  0},
			{x:  4, y:-41}, 
			{x: 56, y:-41},
		];
		this.walk();
	}

	collidesWith(other){
		if (this.state == States.Dead || other.state == States.Dead || other.state == States.Dying) return;

		if (other.state == States.Spinning){
			this.wipe();
		}

		let relativeLocation = this.getRelativeLocationTo(other);
		if ((relativeLocation.left || relativeLocation.right) && this.state != States.Spinning){
			this.dx = -this.dx;
			this.futureX = this.x;			
		}
		if (relativeLocation.above){
			this.dy = 0;
			this.futureY = this.y;
		}
	}

	wipe(){
		this.state = States.Dying;		
		this.behaviours = [new IgnoresTerrain()];
		this.frame = 3;
		this.dy = -0.5;
		sound.kick.play();
	}

	stomp(mario){
		if (this.state == States.Walking){
			this.cower();
		}else if (this.state == States.Cowering){
			this.kick(mario);
		}else if(this.state == States.Spinning){
			this.cower();
		}
	}

	touch(mario){
		if (this.state == States.Cowering){
			this.kick(mario);
		}
	}

	walk(){
		this.state = States.Walking;
		this.behaviours = [new RespectsTerrain(), new ChangesDirectionWhenHittingWalls(), new AnimationBehavior(0,2,300)];
	}

	cower(){
		this.state = States.Cowering;
		this.dx = 0.1 * Math.sign(this.dx);
		this.behaviours = [new AlarmBehavior(3000, "Shake")];
		this.frame = 3;
		sound.stomp.play();
	}

	kick(mario){
		this.behaviours = [new RespectsTerrain(), new ChangesDirectionWhenHittingWalls(), new AnimationBehavior(2,3,75)];
		this.dx = 0.3 * (mario.futureX < this.x) ? 1 : -1;
		this.state = States.Spinning;
		sound.kick.play();
	}

	shake(){
		this.behaviours = [new AnimationBehavior(2,3,100), new AlarmBehavior(500, "Emerge")];
	}

	alarm(name){
		if (name == "Shake"){
			this.shake();
		}else if (name == "Emerge"){
			this.walk();
		}
	}
}

class RedKoopa extends Koopa{
	constructor(x,y,dx,dy){
		super(x,y,dx,dy);
	}

	walk(){
		this.state = States.Walking;
		this.behaviours = [new RespectsTerrain(), new ChangesDirectionWhenHittingWalls(), new AvoidsCliffs(), new AnimationBehavior(0,2,300)];
	}
}

class Game{
	constructor(gfx, controls){
		this.gfx = gfx;
		this.controls = controls;
		this.frame = 0;
		this.treeAnimation = new Animation(3, 500);
		this.coinAnimation = new Animation(3, 333);
		this.turtleAnimation = new Animation(2, 300);
		
		this.screenX = 0;
		this.screenPan = 360;
		this.level = parseLevel();
		this.terrain = new Terrain(this.level);
		this.skyGradient = gfx.createBlueSkyGradient();
		this.lastFacing = 1;
		this.mario = new Mario(360, 461, 0.0, 0.0);
		this.enemies = [];

		this.performance = [];
		this.perfIndex = 0;
		this.spawnEnemies();
	}
	
	update(time){
	    let dt = time - (this.prevTime ?? time);
	    this.prevTime = time;
				
		if (dt == 0 || dt > 1000) return;

		this.treeAnimation.update(dt);
		this.coinAnimation.update(dt);
		this.turtleAnimation.update(dt);
		
		this.updateEnemies(dt);

		this.frame = this.frame-2;
		if (this.frame <=0) this.frame = 41;			
		
		let direction = this.controls.direction;
		
		if (this.controls.jump && this.mario.isTouchingGround){
			this.mario.dy = -1;
			sound.jump.play();
		}

		let facing = this.lastFacing;
		if (direction !=0){
			facing = direction == 1 ? 1 : 0;			
			this.lastFacing = facing;			
		}

		this.mario.dx = 0.2 * direction * (this.controls.run ? 2 : 1);

		if (this.controls.pan != Directions.Idle){
			this.screenPan += Math.round((this.controls.pan == Directions.Left ? 1: -1) * dt * 0.3);

			//clip mario camera offset to 200 pixels off each side of the screen
			if (this.screenPan < 200) this.screenPan = 200;
			if (this.screenPan > 21 * 60 - 200) this.screenPan = 21 * 60 - 200;
		}

		if (this.mario.y > 42*14) {
			this.mario.y = 0;
			sound.die.play();
		}

		this.screenX = Math.floor(this.mario.x) - this.screenPan;

		//Clip screen X to the level size
		if (this.screenX > 60 * (this.level.length-21)) this.screenX = 60 * (this.level.length-21); //21 visible tiles
		if (this.screenX < 0) this.screenX = 0;

		let screenOffset = ((this.screenX % 60)+60)%60; //+60) % 60 solves the negative modulo jump issue
		let tileOffset = Math.floor(this.screenX / 60);
		
		this.spawnEnemies();

		this.performance[this.perfIndex] = dt;
		this.perfIndex = (this.perfIndex + 1) % 40;

		this.gfx.ctx.fillStyle = this.skyGradient;		
		this.gfx.ctx.fillRect(0, 0, 1200, 546);
		this.gfx.ctx.fillStyle = "black";
		let txtx = 10;
		for (let m of this.performance){
			this.gfx.ctx.fillText(m.toFixed(0), txtx, 50);
			txtx += 20;
		}

		if ((this.controls.debug % 3) < 2){
			this.drawTerrain();
			this.drawEnemies();
			this.gfx.drawMario(this.mario.x - this.screenX - 30,this.mario.y - 83,direction != 0 ? this.turtleAnimation.frame : 0,0,facing);
		}
		if ((this.controls.debug % 3) > 0){
			this.drawDebug(dt);
		}

		this.controls.draw(this.gfx);
	}

	spawnEnemies(){
		let tileOffset = Math.floor(this.screenX / 60);
		for (let x=0; x<21;++x){
		    if (x+tileOffset < 0) continue;
			if (x+tileOffset >= this.level.length-1) break;
			for (let y=0; y<13;++y){
				let tileId = this.level[x+tileOffset][y];
				if (tileId == 103+8){
					let goomba = new Goomba(60 * (x+tileOffset),42*y+41,-0.1,0.0);
					this.enemies.push(goomba);
					this.level[x+tileOffset][y] = 255;
				}else if (tileId == 104+8){
					let koopa = new Koopa(60 * (x+tileOffset),42*y+41,-0.1,0.0);
					this.enemies.push(koopa);
					this.level[x+tileOffset][y] = 255;
				}else if (tileId == 105+8){
					let koopa = new RedKoopa(60 * (x+tileOffset),42*y+41,-0.1,0.0);
					this.enemies.push(koopa);
					this.level[x+tileOffset][y] = 255;
				}
			}
		}
	}

	checkEnemiesCollisions(){		
		this.enemies = this.enemies.filter((e)=>e.y < 1000 && e.state != States.Dead);
		
		for (let i = 0; i < this.enemies.length - 1; i++) {
			for (let j = i + 1; j < this.enemies.length; j++) {
				let distance = this.enemies[i].getDistanceFromOtherMoveable(this.enemies[j]);
				if (distance.dx < 0 && distance.dy < 0){
					this.enemies[i].collidesWith(this.enemies[j]);
					this.enemies[j].collidesWith(this.enemies[i]);
				}
			}
    	}
	}

	updateEnemies(dt){
		this.mario.calculateFuturePosition(dt, this.terrain, this.enemies);
		
		for (let e of this.enemies){
			e.calculateFuturePosition(dt, this.terrain, this.enemies);

			let distance = this.mario.getDistanceFromOtherMoveable(e);
				if (distance.dx < 0 && distance.dy < 0){
					this.mario.collidesWith(e);
				}
		}
		
		this.checkEnemiesCollisions();

		for (let e of this.enemies){
			e.applyPosition(dt, this.terrain, this.enemies);
		}		
		this.mario.applyPosition(dt, this.terrain, this.enemies);
	}

	drawEnemies(){
		for (let e of this.enemies){
			if (e.constructor.name == "Goomba"){
				this.gfx.drawGoomba(e.x - this.screenX, e.y, e.frame, 0);
			}else if (e.constructor.name == "Koopa"){
				this.gfx.drawTurtle(e.x - this.screenX, e.y, e.frame, 0, e.dx > 0 ? 1 : 0);
			}else if (e.constructor.name == "RedKoopa"){
				this.gfx.drawTurtle(e.x - this.screenX, e.y, e.frame, 1, e.dx > 0 ? 1 : 0);
			}
		}
	}

	drawTerrain(){
		let screenOffset = ((this.screenX % 60)+60)%60; //+60) % 60 solves the negative modulo jump issue
		let tileOffset = Math.floor(this.screenX / 60);
		for (let x=-2; x<21 +1;++x){
		    if (x+tileOffset < 0) continue;
			if (x+tileOffset >= this.level.length-1) break;
			for (let y=0; y<13;++y){
			   let tileId = this.level[x+tileOffset][y];
			   if (tileId != 255){				   				  
		           if (tileId == 101+8){
					  this.gfx.drawCoin(60 * x - screenOffset, 42 * y + 16, this.coinAnimation.frame);
				   }else if (tileId == 102+8){
					  this.gfx.drawWeed(60 * x - screenOffset, 42 * y + 16, this.treeAnimation.frame);					
				   }else if (tileId == 100+8){
					  this.gfx.drawTree(60 * x - screenOffset, 42 * y + 16, this.treeAnimation.frame);
				   }else if (tileId == 13+8){
					  this.gfx.drawWater(60 * x - screenOffset, 42*y+16, this.frame);
				   }else if (tileId < 8){
				     this.gfx.drawTile(60 * x - screenOffset, 42*y, tileId, 0);
                   }else{
				     this.gfx.drawTileOld(60 * x - screenOffset, 42*y, tileId-8);
                   }				   
			   }
		   }
		}
		//this.gfx.drawSpiney(60 * x - screenOffset, 42 * y + 16, this.turtleAnimation.frame, 1);
		//this.gfx.drawFish(60 * x - screenOffset, 42 * y + 16, this.turtleAnimation.frame, 1);
	}
	
	drawDebug(dt){
		let screenOffset = ((this.screenX % 60)+60)%60; //+60) % 60 solves the negative modulo jump issue
		let tileOffset = Math.floor(this.screenX / 60);
		//Draw Grid
		this.gfx.ctx.strokeStyle = "darkGray";
		for (let x=0; x<21;++x){
			this.gfx.ctx.beginPath();
	        this.gfx.ctx.moveTo(x * 60 - screenOffset, 0);
		    this.gfx.ctx.lineTo(x * 60 - screenOffset, 13 * 42);
	        this.gfx.ctx.stroke();
		}
		for (let y=0; y<13;++y){
			this.gfx.ctx.beginPath();
	        this.gfx.ctx.moveTo(0,       y * 42);
		    this.gfx.ctx.lineTo(21 * 60, y * 42);
	        this.gfx.ctx.stroke();
		}

		//Draw Solid blocks
		this.gfx.ctx.strokeStyle = "red";
		for (let x=0; x<21;++x){
		    if (x+tileOffset < 0) continue;
			if (x+tileOffset >= this.level.length-1) break;
			for (let y=0; y<13;++y){
			   if (this.terrain.isSolid(x+tileOffset,y)){
				   this.gfx.ctx.strokeRect(x * 60 - screenOffset, y * 42, 60, 42);
			   }
		    }
		}
		
		//Draw mario direction
		this.gfx.ctx.strokeStyle = "green";
		this.gfx.ctx.beginPath();
        this.gfx.ctx.moveTo(this.mario.x - this.screenX, this.mario.y);
	    this.gfx.ctx.lineTo(this.mario.x + this.mario.dx * dt * 5 - this.screenX, this.mario.y + this.mario.dy * dt * 5);
        this.gfx.ctx.stroke();
		//Draw mario location
		this.gfx.ctx.beginPath();
		this.gfx.ctx.arc(this.mario.x - this.screenX,this.mario.y, 5, 0, 2 * Math.PI);
		this.gfx.ctx.stroke();
		//Draw Mario collison points
		for (let p of this.mario.collisionPoints){
			this.gfx.ctx.beginPath();
			this.gfx.ctx.arc(this.mario.x - this.screenX + p.x, this.mario.y + p.y, 3, 0, 2 * Math.PI);
			this.gfx.ctx.stroke();
		}

		for (let e of this.enemies){
			for (let p of e.collisionPoints){
				this.gfx.ctx.beginPath();
				this.gfx.ctx.arc(e.x - this.screenX + p.x, e.y + p.y, 3, 0, 2 * Math.PI);
				this.gfx.ctx.stroke();
			}	
		}
	}
}

function initGame(){
	var canvas = document.getElementById("MyCanvas");
	var ctx = canvas.getContext("2d");
	var graphics = new Graphics(ctx);

	var keyboard = new Keyboard(canvas);
	var touch = new Touch(canvas);
	var controls;

	if (navigator.userAgent.match(/Android/i)
         || navigator.userAgent.match(/webOS/i)
         || navigator.userAgent.match(/iPhone/i)
         || navigator.userAgent.match(/iPad/i)
         || navigator.userAgent.match(/iPod/i)
         || navigator.userAgent.match(/BlackBerry/i)
         || navigator.userAgent.match(/Windows Phone/i)) {
		controls = touch;
	} else {
		controls = keyboard;
	}
	
	var game = new Game(graphics, controls);
	setInterval(()=>window.requestAnimationFrame((time)=>game.update(time)), 16);
}
</script>
</head>
<body onload="initGame()">
   <canvas id="MyCanvas" width="1200" height="546" style="border:1px solid #000000; background-color:#5080A0;"></canvas>
</body>
</html>