<!DOCTYPE html>‚Äù
<html>
<head>
<script src="graphics.js"></script>
<script src="levels.js"></script>
<script src="keyboard.js"></script>
<script src="touch.js"></script>
<script src="sound.js"></script>
<style>
html, body {
  margin: 0;
}
</style>

<script>
class Animation{
  constructor(frames, transitionTime){
     this.frames = frames; 
     this.transitionTime = transitionTime;
	 this.frame = 0;
	 this.t = 0;
  }
  
  update(dt){
     this.t = this.t + dt;
     this.frame = (this.frame + Math.floor(this.t / this.transitionTime)) % this.frames;
	 this.t = this.t > this.transitionTime ? this.t - this.transitionTime : this.t;
  }
  
}

function noNaN(x){
	if (isNaN(x))
		return 0;
	return x;
}
	
class Terrain{
	constructor(tiles){
		this.tiles = tiles;
		this.tileWidth = 60;
		this.tileHeight = 42;
	}

	inBounds(X,Y){
		return X >= 0 && X < this.tiles.length && Y >= 0 && Y < this.tiles[X].length;
	}

	isSolid(X,Y){
		return this.inBounds(X,Y) && (this.tiles[X][Y] < 8 || [9,20,26,27,32,33,67].includes(this.tiles[X][Y]));
	}
	
	getPointCollisonDistance(x, y, dx, dy, tMax, wantNonSolid){		
        //Ref: A fast voxel traversal algorithm J.Amanatides, A. Woo      
		//(x,y) the location of the point. 
		//(dx, dy) the normalized speed of the point in pixels per second. 
		//tMax the number of seconds the point intents to travel

        //Distance in seconds between two consecutive lines when moving at direction (dx,dy)
        let tVertical    = this.tileWidth  / Math.abs(dx);
        let tHorizontal  = this.tileHeight / Math.abs(dy);

        //Starting Tile location
        let X = Math.floor(x / this.tileWidth);
        let Y = Math.floor(y / this.tileHeight);

		//Ending Tile location
        let endX = Math.floor((x + dx * tMax) / this.tileWidth);
        let endY = Math.floor((y + dy * tMax) / this.tileHeight);

		let tNextVertical, tNextHorizontal; //The distance in seconds to the next line
        let stepX, stepY;                   //The direction we move across tiles        

        if (dx >= 0.0){
            stepX = 1;
            tNextVertical = ((X+1) * this.tileWidth - x) / dx;
        }else{
            stepX = -1;
            tNextVertical = (X * this.tileWidth - x) / dx;
        }

        if (dy >= 0.0){
            stepY = 1;
            tNextHorizontal = ((Y+1) * this.tileHeight - y) / dy;
        }else{
            stepY = -1;
            tNextHorizontal = (Y * this.tileHeight - y) / dy;
        }

		if (isNaN(tNextVertical) || isNaN(tNextHorizontal)){
			debugger;
		}

        if (this.isSolid(X, Y) && !wantNonSolid) {
			//this tries to solve the problem if mario happens to be inside a solid block.
			//the idea is to flip the direction and call the inverse of this function to find the first non-solid
            return this.getPointCollisonDistance(x,y,-dx,-dy, 10000, true); 
        }

        let t = 0.0;
        while ((X != endX || Y !=endY) && (t < tMax)){
            if(tNextVertical < tNextHorizontal){
                t = tNextVertical;
                tNextVertical += tVertical;
                X += stepX;

				if (this.isSolid(X, Y) ^ wantNonSolid) {
					if (!wantNonSolid){
                		return t - noNaN(stepX / dx); //Return t at one pixel before the collision with the solid vertical line
					} else {
						return t + noNaN(stepX / dx); //Return t at one pixel after the collision with the non-solid vertical line
					}
				}
            }else{
                t = tNextHorizontal;
                tNextHorizontal += tHorizontal;
                Y += stepY;

				if (this.isSolid(X, Y) ^ wantNonSolid) {
					if (!wantNonSolid){
                		return t - noNaN(stepY / dy); //Return t at one pixel before the collision with the vertical line
					} else {
						return t + noNaN(stepY / dy);
					}
				}
            }
        }
        return tMax;
    }
}

class Moveable{
	constructor(x, y, dx, dy){
		this.x = x;     //in pixels
		this.y = y;     //in pixels
		this.dx = dx;   //in pixels per millisecond
		this.dy = dy;   //in pixels per millisecond
		this.ay = 0.0025;  //in pixels per millisecond per millisecond
		this.dyTerminal = 1.0; //in pixels per millisecond
		this.isTouchingGround = false;
		this.isBumpingCeiling = false;
		this.collisionPoints = [];
	}

	getCollisionDistance(terrain, x,y,dx,dy,dt){
		let minT = 99999999999;
		for (let p of this.collisionPoints){
			let t = terrain.getPointCollisonDistance(x + p.x, y + p.y, dx, dy, dt, false);
			minT = Math.min(minT, t);
		}
		return minT;
	}

	update(dt, terrain){
		let tDiagonal = this.getCollisionDistance(terrain, this.x, this.y, this.dx, this.dy, dt);
		this.x = this.x + this.dx * tDiagonal;
		this.y = this.y + this.dy * tDiagonal;
		//check if mario can move stricly in dx or dy for the remainder of the distance
		let tHorizontal = this.getCollisionDistance(terrain, this.x, this.y, this.dx, 0.0, dt - tDiagonal);
		this.x = this.x + this.dx * tHorizontal;		
		let tVertical = this.getCollisionDistance(terrain, this.x, this.y, 0.0, this.dy, dt - tDiagonal);
		this.y = this.y + this.dy * tVertical;
		
		if (isNaN(this.x) || isNaN(this.y)){
			debugger;
		}

		this.isTouchingGround = this.getCollisionDistance(terrain, this.x, this.y, 0.0,  1.0, 2.0) <= 1.0;
		this.isBumpingCeiling = this.getCollisionDistance(terrain, this.x, this.y, 0.0, -1.0, 2.0) <= 1.0;
		
		if (!this.isTouchingGround)
			this.dy = Math.min(this.dy + this.ay * dt, this.dyTerminal);
		else
			this.dy = 0.0;

		if (this.isBumpingCeiling && this.dy < 0.0)
			this.dy = 0.0;
	}
}

class Mario extends Moveable{
	constructor(x,y,dx,dy){
		super(x,y,dx,dy);
		this.collisionPoints = [
			{x:-26, y:  0}, 
			{x: 26, y:  0},
			{x:-26, y:-50}, 
			{x: 26, y:-50},
			{x:-26, y:-25}, 
			{x: 26, y:-25},
		];
	}
}

class Goomba extends Moveable{
	constructor(x,y,dx,dy){
		super(x,y,dx,dy);
		this.collisionPoints = [
			{x:  4, y:  0}, 
			{x: 56, y:  0},
			{x:  4, y:-41}, 
			{x: 56, y:-41},
		];
	}

	update(dt, terrain){
		super.update(dt,terrain);
		let isHittingLeftWall = this.getCollisionDistance(terrain, this.x, this.y, -1.0, 0.0, 2.0) <= 1.0;
		let isHittingRightWall = this.getCollisionDistance(terrain, this.x, this.y, 1.0, 0.0, 2.0) <= 1.0;

		if (isHittingLeftWall && !isHittingRightWall){
			this.dx = Math.abs(this.dx);
		}
		if (!isHittingLeftWall && isHittingRightWall){
			this.dx = -Math.abs(this.dx);
		}
	}
}

class Koopa extends Moveable{
	constructor(x,y,dx,dy){
		super(x,y,dx,dy);
		this.collisionPoints = [
			{x:  4, y:  0}, 
			{x: 56, y:  0},
			{x:  4, y:-41}, 
			{x: 56, y:-41},
		];
	}

	update(dt, terrain){
		super.update(dt,terrain);
		let isHittingLeftWall = this.getCollisionDistance(terrain, this.x, this.y, -1.0, 0.0, 2.0) <= 1.0;
		let isHittingRightWall = this.getCollisionDistance(terrain, this.x, this.y, 1.0, 0.0, 2.0) <= 1.0;

		if (isHittingLeftWall && !isHittingRightWall){
			this.dx = Math.abs(this.dx);
		}
		if (!isHittingLeftWall && isHittingRightWall){
			this.dx = -Math.abs(this.dx);
		}
	}
}

class RedKoopa extends Moveable{
	constructor(x,y,dx,dy){
		super(x,y,dx,dy);
		this.collisionPoints = [
			{x:  4, y:  0}, 
			{x: 56, y:  0},
			{x:  4, y:-41}, 
			{x: 56, y:-41},
		];
	}

	update(dt, terrain){
		super.update(dt,terrain);
		let isHittingLeftWall  = this.getCollisionDistance(terrain, this.x, this.y, -1.0, 0.0, 2.0) <= 1.0;
		let isHittingRightWall = this.getCollisionDistance(terrain, this.x, this.y, 1.0, 0.0, 2.0) <= 1.0;

		let isLeftFootOnAir  = terrain.getPointCollisonDistance(this.x + this.collisionPoints[0].x, this.y + this.collisionPoints[0].y, 0.0, 1.0, 2.0, false) > 1.0;
		let isRightFootOnAir = terrain.getPointCollisonDistance(this.x + this.collisionPoints[1].x, this.y + this.collisionPoints[1].y, 0.0, 1.0, 2.0, false) > 1.0;

		if (isHittingLeftWall || (this.isTouchingGround && isLeftFootOnAir)){
			this.dx = Math.abs(this.dx);
		}

		if (isHittingRightWall || (this.isTouchingGround && isRightFootOnAir)){
			this.dx = -Math.abs(this.dx);
		}
	}
}

class Game{
	constructor(gfx, controls){
		this.gfx = gfx;
		this.controls = controls;
		this.frame = 0;
		this.treeAnimation = new Animation(3, 500);
		this.coinAnimation = new Animation(3, 333);
		this.turtleAnimation = new Animation(2, 300);
		
		this.screenX = 0;
		this.screenPan = 360;
		this.level = parseLevel();
		this.terrain = new Terrain(this.level);
		this.skyGradient = gfx.createBlueSkyGradient();
		this.lastFacing = 1;
		this.mario = new Mario(360, 461, 0.0, 0.0);				
		this.enemies = [];
		this.spawnEnemies();
	}
	
	update(time){
	    let dt = time - (this.prevTime ?? time);
	    this.prevTime = time;
				
		if (dt == 0 || dt > 1000) return;

		this.treeAnimation.update(dt);
		this.coinAnimation.update(dt);
		this.turtleAnimation.update(dt);
		this.mario.update(dt, this.terrain);
		this.updateEnemies(dt);

		this.frame = this.frame-2;
		if (this.frame <=0) this.frame = 41;			
		
		let direction = this.controls.direction;
		
		if (this.controls.jump && this.mario.isTouchingGround){
			this.mario.dy = -1;
			sound.jump.play();
		}

		let facing = this.lastFacing;
		if (direction !=0){
			facing = direction == 1 ? 1 : 0;			
			this.lastFacing = facing;			
		}

		this.mario.dx = 0.2 * direction * (this.controls.run ? 2 : 1);

		if (this.controls.pan != Directions.Idle){
			this.screenPan += Math.round((this.controls.pan == Directions.Left ? 1: -1) * dt * 0.3);

			//clip mario camera offset to 200 pixels off each side of the screen
			if (this.screenPan < 200) this.screenPan = 200;
			if (this.screenPan > 21 * 60 - 200) this.screenPan = 21 * 60 - 200;
		}

		if (this.mario.y > 42*14) {
			this.mario.y = 0;
			sound.die.play();
		}

		this.screenX = Math.floor(this.mario.x) - this.screenPan;

		//Clip screen X to the level size
		if (this.screenX > 60 * (this.level.length-21)) this.screenX = 60 * (this.level.length-21); //21 visible tiles
		if (this.screenX < 0) this.screenX = 0;

		let screenOffset = ((this.screenX % 60)+60)%60; //+60) % 60 solves the negative modulo jump issue
		let tileOffset = Math.floor(this.screenX / 60);
		
		this.spawnEnemies();

		this.gfx.ctx.fillStyle = this.skyGradient;		
		this.gfx.ctx.fillRect(0, 0, 1200, 546);
		this.gfx.ctx.fillStyle = "black";
		this.gfx.ctx.fillText(dt.toFixed(0), 10, 50);

		if ((this.controls.debug % 3) < 2){
			this.drawTerrain();
			this.drawEnemies();
			this.gfx.drawMario(this.mario.x - this.screenX - 30,this.mario.y - 83,direction != 0 ? this.turtleAnimation.frame : 0,0,facing);
		}
		if ((this.controls.debug % 3) > 0){
			this.drawDebug(dt);
		}

		this.controls.draw(this.gfx);
	}

	spawnEnemies(){
		let tileOffset = Math.floor(this.screenX / 60);
		for (let x=0; x<21;++x){
		    if (x+tileOffset < 0) continue;
			if (x+tileOffset >= this.level.length-1) break;
			for (let y=0; y<13;++y){
				let tileId = this.level[x+tileOffset][y];
				if (tileId == 103+8){
					let goomba = new Goomba(60 * (x+tileOffset),42*y+41,-0.1,0.0);
					this.enemies.push(goomba);
					this.level[x+tileOffset][y] = 255;
				}else if (tileId == 104+8){
					let koopa = new Koopa(60 * (x+tileOffset),42*y+41,-0.1,0.0);
					this.enemies.push(koopa);
					this.level[x+tileOffset][y] = 255;
				}else if (tileId == 105+8){
					let koopa = new RedKoopa(60 * (x+tileOffset),42*y+41,-0.1,0.0);
					this.enemies.push(koopa);
					this.level[x+tileOffset][y] = 255;
				}
			}
		}
	}

	updateEnemies(dt){
		for (let e of this.enemies){
			e.update(dt, this.terrain)
		}
	}

	drawEnemies(){
		for (let e of this.enemies){
			if (e.constructor.name == "Goomba"){
				this.gfx.drawGoomba(e.x - this.screenX, e.y -41, this.turtleAnimation.frame,0);
			}else if (e.constructor.name == "Koopa"){
				this.gfx.drawTurtle(e.x - this.screenX, e.y -65, this.turtleAnimation.frame, 0, e.dx > 0 ? 1 : 0);
			}else if (e.constructor.name == "RedKoopa"){
				this.gfx.drawTurtle(e.x - this.screenX, e.y -65, this.turtleAnimation.frame, 1, e.dx > 0 ? 1 : 0);
			}
		}
	}

	drawTerrain(){
		let screenOffset = ((this.screenX % 60)+60)%60; //+60) % 60 solves the negative modulo jump issue
		let tileOffset = Math.floor(this.screenX / 60);
		for (let x=-2; x<21 +1;++x){
		    if (x+tileOffset < 0) continue;
			if (x+tileOffset >= this.level.length-1) break;
			for (let y=0; y<13;++y){
			   let tileId = this.level[x+tileOffset][y];
			   if (tileId != 255){				   				  
		           if (tileId == 101+8){
					  this.gfx.drawCoin(60 * x - screenOffset, 42 * y + 16, this.coinAnimation.frame);
				   }else if (tileId == 102+8){
					  this.gfx.drawWeed(60 * x - screenOffset, 42 * y + 16, this.treeAnimation.frame);
				   }else if (tileId == 103+8){
					  //this.gfx.drawGoomba(60 * x - screenOffset, 42 * y + 16, this.turtleAnimation.frame,0);
				   }else if (tileId == 104 +8|| tileId == 105+8){
					  //this.gfx.drawTurtle(60 * x - screenOffset, 42 * y + 16, this.turtleAnimation.frame, 1-(tileId - 104),0);
					  //this.gfx.drawShell(60 * x - screenOffset, 42 * y + 16, this.turtleAnimation.frame, 1-(tileId - 104),0);
					  //this.gfx.drawSpiney(60 * x - screenOffset, 42 * y + 16, this.turtleAnimation.frame, 1);
					  //this.gfx.drawFish(60 * x - screenOffset, 42 * y + 16, this.turtleAnimation.frame, 1);
				   }else if (tileId == 100+8){
					  this.gfx.drawTree(60 * x - screenOffset, 42 * y + 16, this.treeAnimation.frame);
				   }else if (tileId == 13+8){
					  this.gfx.drawWater(60 * x - screenOffset, 42*y+16, this.frame);
				   }else if (tileId < 8){
				     this.gfx.drawTile(60 * x - screenOffset, 42*y, tileId, 0);
                   }else{
				     this.gfx.drawTileOld(60 * x - screenOffset, 42*y, tileId-8);
                   }				   
			   }
		   }
		}
	}
	
	drawDebug(dt){
		let screenOffset = ((this.screenX % 60)+60)%60; //+60) % 60 solves the negative modulo jump issue
		let tileOffset = Math.floor(this.screenX / 60);
		//Draw Grid
		this.gfx.ctx.strokeStyle = "darkGray";
		for (let x=0; x<21;++x){
			this.gfx.ctx.beginPath();
	        this.gfx.ctx.moveTo(x * 60 - screenOffset, 0);
		    this.gfx.ctx.lineTo(x * 60 - screenOffset, 13*42);
	        this.gfx.ctx.stroke();
		}
		for (let y=0; y<13;++y){
			this.gfx.ctx.beginPath();
	        this.gfx.ctx.moveTo(0, y*42);
		    this.gfx.ctx.lineTo(21 * 60, y*42);
	        this.gfx.ctx.stroke();
		}

		//Draw Solid blocks
		this.gfx.ctx.strokeStyle = "red";
		for (let x=0; x<21;++x){
		    if (x+tileOffset < 0) continue;
			if (x+tileOffset >= this.level.length-1) break;
			for (let y=0; y<13;++y){
			   if (this.terrain.isSolid(x+tileOffset,y)){
				   this.gfx.ctx.strokeRect(x * 60 - screenOffset, y*42, 60,42);
			   }
		    }
		}
		
		//Draw mario direction
		this.gfx.ctx.strokeStyle = "green";
		this.gfx.ctx.beginPath();
        this.gfx.ctx.moveTo(this.mario.x - this.screenX, this.mario.y);
	    this.gfx.ctx.lineTo(this.mario.x + this.mario.dx * dt * 5 - this.screenX, this.mario.y + this.mario.dy * dt * 5);
        this.gfx.ctx.stroke();
		//Draw mario location
		this.gfx.ctx.beginPath();
		this.gfx.ctx.arc(this.mario.x - this.screenX,this.mario.y, 5, 0, 2 * Math.PI);
		this.gfx.ctx.stroke();
		//Draw Mario collison points
		for (let p of this.mario.collisionPoints){
			this.gfx.ctx.beginPath();
			this.gfx.ctx.arc(this.mario.x - this.screenX + p.x, this.mario.y + p.y, 3, 0, 2 * Math.PI);
			this.gfx.ctx.stroke();
		}

		for (let e of this.enemies){
			for (let p of e.collisionPoints){
				this.gfx.ctx.beginPath();
				this.gfx.ctx.arc(e.x - this.screenX + p.x, e.y + p.y, 3, 0, 2 * Math.PI);
				this.gfx.ctx.stroke();
			}	
		}
	}
}

function initGame(){
	var canvas = document.getElementById("MyCanvas");
	var ctx = canvas.getContext("2d");
	var graphics = new Graphics(ctx);

	var keyboard = new Keyboard(canvas);
	var touch = new Touch(canvas);
	var controls;

	if (navigator.userAgent.match(/Android/i)
         || navigator.userAgent.match(/webOS/i)
         || navigator.userAgent.match(/iPhone/i)
         || navigator.userAgent.match(/iPad/i)
         || navigator.userAgent.match(/iPod/i)
         || navigator.userAgent.match(/BlackBerry/i)
         || navigator.userAgent.match(/Windows Phone/i)) {
		controls = touch;
	} else {
		controls = keyboard;
	}
	
	var game = new Game(graphics, controls);
	setInterval(()=>window.requestAnimationFrame((time)=>game.update(time)), 16);
}
</script>
</head>
<body onload="initGame()">
   <canvas id="MyCanvas" width="1200" height="546" style="border:1px solid #000000; background-color:#5080A0;"></canvas>
</body>
</html>